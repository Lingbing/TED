{
    "contents" : "#' Impute missing values by automated variable selection\n#'\n#' @param missdata data matrix with missing values encoded as NA.\n#' @param lmFun the variable selection method for continuous data.\n#' @param cFun the variable selection method for categorical data.\n#' @param ini the method for initilisation. It is a length one character if\n#' missdata contains only one type of variables only. For continous only data, \n#' ini can be \"mean\" (mean imputation), \"median\" (median imputation) or \"random\"\n#'  (random guess), the default is \"mean\". For categorical data, it can be \n#'  either \"majority\" or \"random\", the default is \"majority\". If missdata is \n#'  mixed of continuous and categorical data, then ini has to be a vector of two\n#'  characters, with the first element indicating the method for continous \n#'  variables and the other element for categorical variables, and the default\n#'  is c(\"mean\", \"majority\".)\n#' @param maxiter is the maximum number of interations\n#' @param verbose is logical, if TRUE then detailed information will\n#' be printed in the console while running.\n#' @param conv logical, if TRUE, the convergence details will be returned\n#' @export\n#' @return if conv = FALSE, then a completed data matrix, if TRUE, a list\n\nimpute <- function(missdata, lmFun = NULL, cFun = NULL, ini = NULL, \n                   maxiter = 100, verbose = TRUE, conv = TRUE) {\n  ## Detect variable types for the missing data and distribute appropriate tasks\n  Type <- Detect(missdata)\n  if(all(Type == \"numeric\")) {\n    task <- 1\n    if(is.null(ini)) {\n      ini = \"mean\"\n    } else {\n      stopifnot(ini %in% c(\"mean\", \"median\", \"random\"))\n    }\n    names(task) <- \"Regression\"\n  } else if(all(Type == \"character\")) {\n    task <- 2\n    if(is.null(ini)) {\n      ini = \"majority\"\n    } else {\n      stopifnot(ini %in% c(\"majority\", \"random\"))\n    }\n    names(task) <- 'Classification'\n  } else {\n    task <- 3\n    if(is.null(ini)) {\n      ini = c(\"mean\", \"majority\")\n    } else {\n      if (length(ini) !=2) {\n        stop (\"Data are mixed-type, provide two initial methods\")\n      } else {\n        if (!(ini[1] %in% c(\"mean\", \"median\", \"random\")) || \n              !(ini[2] %in% c(\"majority\", \"random\"))) {\n          stop (\"ini has to be a two length character vector, check the help\n                about this argument and make sure you provide valid names\")\n        }\n      }\n    }\n    names(task) <- \"Regression and Classification mixed\"\n  }\n  if (verbose) {\n    cat(\"Imputation task is:\", names(task), \"\\n\")\n  }\n  \n  if (task == 1) {\n    stopifnot(!is.null(lmFun))\n    lmFUN <- match.fun(lmFun)\n    cFUN <- NULL\n  } else if (task == 2) {\n    stopifnot(!is.null(cFun))\n    lmFUN <- NULL\n    cFUN <- match.fun(cFun)\n  } else {\n    stopifnot(!is.null(cFun), !is.null(lmFun))\n    lmFUN <- match.fun(lmFun)\n    cFUN <- match.fun(cFun)\n  }\n  n <- nrow(missdata)\n  p <- ncol(missdata)\n  \n  ## remove completely missing variables\n  if (any(apply(is.na(missdata), 2, sum) == n)) {\n    ind <- which(apply(is.na(missdata), 2, sum) == n)\n    missdata <- missdata[, -ind]\n    p <- ncol(missdata)\n    cat('removed variable(s)', ind,\n        'due to the missingness of all entries\\n')\n  }\n  ## perform initial guess on miss \n  ximp <- missdata\n  if (task == 1) {\n    ximp <- guess(ximp, type = ini)\n  } else if (task == 2) {\n    ximp <- guess(ximp, type = ini)\n  } else {\n    for (i in seq_along(Type)) {\n      if (Type[i] == \"numeric\") {\n        ximp[, i] <- guess(missdata[, i], type = ini[1])\n        } else {\n          if (ini[2] == \"majority\") {\n            ximp[, i] <- as.numeric(major(missdata[, i]))\n          } else {\n            ximp[, i] <- guess(missdata[, i], type = \"random\")\n          }\n        }\n    }\n  }\n  \n  # extract missingness pattern\n  NAloc <- is.na(missdata)\n  noNAvar <- apply(NAloc, 2, sum) # how many are missing in the vars\n  sort.j <- order(noNAvar, decreasing = TRUE) # indices of increasing amount of NA in vars\n  sort.noNAvar <- noNAvar[sort.j]\n  \n  # ready for output\n  Ximp <- vector('list', maxiter)\n  \n  iter <- 0\n  k <- length(unique(Type))\n  convNew <- rep(0, k)\n  convOld <- rep(Inf, k)\n  \n  # setup convergence container w.r.t. task types\n  if (k == 1) {\n    if (unique(Type) == 'numeric'){\n      names(convNew) <- c('numeric')\n    } else {\n      names(convNew) <- c('character')\n    }\n    Converg <- rep(NA, maxiter)\n  } else {\n    names(convNew) <- c('numeric', 'character')\n    Converg <- matrix(NA, nrow = maxiter, ncol = 2)\n  }\n  \n  # stopping function for the loop\n  stopCriterion <- function(Type, convNew, convOld, iter, maxiter) {\n    k <- length(unique(Type))\n    if (k == 1) {\n      (convNew < convOld) & (iter < maxiter)\n    } else {\n      ((convNew[1] < convOld[1]) | (convNew[2] < convOld[2])) & (iter < maxiter)\n    }\n  }\n\n  while (stopCriterion(Type, convNew, convOld, iter, maxiter)) {\n    if (iter != 0){\n      convOld <- convNew     \n    }\n    \n    if (verbose) {\n      if (task == 1) {\n        cat(\"iteration\", iter + 1,  \"using\", lmFun, \n          \"in progress...\")\n      } else if (task == 2) {\n        cat(\"iteration\", iter + 1,  \"using\", cFun, \n            \"in progress...\")\n      } else {\n        cat(\"iteration\", iter + 1,  \"using\", lmFun, \"and\", cFun, \n            \"in progress...\")\n      }\n    }\n    \n    ximp.old <- ximp\n    for (s in 1:p) {\n      varInd <- sort.j[s]\n      if (noNAvar[[varInd]] != 0) {\n        obsi <- !NAloc[, varInd] # which i's are observed\n        misi <- NAloc[, varInd] # which i's are missing\n        obsY <- ximp[obsi, varInd] # training response\n        obsX <- as.matrix(ximp[obsi, seq(1, p)[-varInd]]) # training variables\n        colnames(obsX) <- paste0(\"x\", 1:ncol(obsX))\n        misX <- as.matrix(ximp[misi, seq(1, p)[-varInd]]) # predictors\n\n        # as.df can be overwritten if some known functions that require data.frame\n        # by their preidction function are called.\n        if (task == 1 && (lmFun %in% \n             c(\"stepR\", \"ridgeR\", \"stepBothR\", \"stepBackR\", \"stepForR\"))) {\n          # some class of predction functions require that the newdata be\n          # a data.frame rather than a matrix, so we need to tranform the \n          # new data (matrix) into a data frame \n          misX <- as.data.frame(misX)\n        } else if (task == 2 && (cFun %in% \n                     c(\"stepBothC\", \"stepBackC\", \"stepForC\", \"rpartC\",\n                       \"treeC\", \"gbmC\", \"ridgeC\"))) {\n          misX <- as.data.frame(misX)\n        } else if (task == 3) {\n          if ((lmFun %in% c(\"stepR\", \"ridgeR\", \"stepBothR\", \"stepBackR\", \"stepForR\")) ||\n                (cFun %in% c(\"stepBothC\", \"stepBackC\", \"stepForC\", \"rpartC\",\n                  \"treeC\", \"gbmC\", \"ridgeC\")))\n            misX <- as.data.frame(misX)\n        }\n        \n        colnames(misX) <- colnames(obsX)\n        typeY <- Type[varInd]\n\n        ## train model (with automated variable selction) on observed data\n        if (typeY == \"numeric\") {\n          Miss <- lmFUN(x = obsX, y = obsY)\n          if (lmFun %in% c(\"pcrR\", \"plsR\")) {\n            misY <- predict(Miss, misX, ncomp = 2, type = \"response\")\n          } else if (lmFun == \"CubistR\") {\n            misY <- predict(Miss$model, misX, neighbors = Miss$neighbors)\n          } else {\n            misY <- predict(Miss, misX)\n          }\n        } else {\n          obsY2 <- factor(obsY)\n          summarY <- summary(obsY2)\n          if (length(summarY) == 1) {\n            # if all values of obsY is the same then using model would be \n            # unnecessary\n            misY <- factor(rep(names(summarY), sum(misi)))\n          } else {\n            if (cFun %in% c(\"randomForest\", \"rdaC\", \"RRF\")) {\n              obsY <- factor(obsY)\n            }\n            Miss <- cFUN(x = obsX, y = obsY)\n            if (cFun %in% c(\"stepBothC\", \"stepBackC\", \"stepForC\", \n                            \"lassoC\", \"ridgeC\")) {\n              misY <- ifelse(predict(Miss, misX, type = \"response\") < 0.5, 0, 1)\n              } else if (cFun %in% c(\"rpartC\", \"randomForest\", \"RRF\")) {\n              try <- predict(Miss, misX, type = \"prob\")\n              misY <- ifelse(try[, 1] > try[, 2], 0, 1)\n              } else if (cFun == \"treeC\") {\n                misY <- predict(Miss, misX, type = \"class\")\n              } else if (cFun == \"rdaC\") {\n                try <- predict(Miss$fit, Miss$x, Miss$y, xnew = t(misX), alpha = Miss$alpha,\n                              delta = Miss$delta, type = \"posterior\")\n                misY <- ifelse(try[, 1] > try[, 2], 0, 1)\n              } else if (cFun == \"gbmC\") {\n                try <- predict(Miss$model, misX, Miss$best, type = \"response\")\n                misY <- ifelse(try < 0.5, 0, 1)\n              } else {\n              misY <- predict(Miss, misX)\n              }\n          }\n        }  \n        ## replace old imputed value with prediction\n        ximp[misi, varInd] <- misY\n      }\n    }  \n    if (verbose) {\n      cat('done!\\n')\n    }\n    iter <- iter + 1\n    Ximp[[iter]] <- ximp\n    # check the difference between iteration steps\n    # This implementation is really smart and is derived from the brillian MissForest\n    # package source.\n    t.co2 <- 1\n        for (t.type in names(convNew)) {\n            t.ind <- which(Type == t.type)\n            if (t.type == \"numeric\") {\n                convNew[t.co2] <- sum((ximp[, t.ind] - ximp.old[, t.ind])^2)/sum(ximp[, t.ind]^2)\n            } else {\n                dist <- sum(as.character(as.matrix(ximp[, t.ind])) != \n                  as.character(as.matrix(ximp.old[, t.ind])))\n                convNew[t.co2] <- dist/(n * sum(Type == \"character\"))\n            }\n            t.co2 <- t.co2 + 1\n        }\n    if (conv) {\n      if (k == 1) {\n        Converg[iter] <- convNew\n      } else {\n        Converg[iter, ] <- convNew\n      }\n    }\n    if (verbose) {\n      if (task == 3) {\n        cat(\"Difference after iteration\", iter,  \"is\", convNew[1],\n            \"and\", convNew[2], \"\\n\") \n      } else {\n        cat(\"Difference after iteration\", iter,  \"is\", convNew, \"\\n\")\n      }\n    }\n  }\n  \n  ## produce output w.r.t. stopping rule\n  if (iter == maxiter){\n    ximp = Ximp[[iter]]\n  } else {    \n    ximp = Ximp[[iter - 1]]\n  }\n  if (conv) {\n    Converg <- na.omit(Converg)\n    return(list(imp = ximp, conv = Converg))\n  }\n  return(ximp)\n}\n",
    "created" : 1395562851973.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1510175347",
    "id" : "A27C53DC",
    "lastKnownWriteTime" : 1395428976,
    "path" : "~/Downloads/deleted/impute-master-2/R/impute.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}