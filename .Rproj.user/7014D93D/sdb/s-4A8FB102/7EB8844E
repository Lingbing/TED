{
    "contents" : "#' Introduce some missing values into a data matrix\n#' \n#' This function randomly introduce some amount of missing values into a matrix\n#' \n#' @param data a data matrix to simulate\n#' @param p the percentage of missing values introduced into the data matrix\n#'    it should be a value between 0 and 1.\n#' @keywords simulation, imputation\n#' @export\n#' @examples\n#' simdata <- matrix(rnorm(100), 10, 10)\n#' missingdata <- SimIm(simdata, p = 0.15)\n#' # count the number of missing values afterwards\n#' sum(is.na(missingdata))\n\nSimIm <- function(data, p = 0.1) {\n  vec <- c(unlist(data))\n  missing <- rbinom(length(vec), 1, p)\n  vec[missing == 1] <- NA\n  dim(vec) <- dim(data)\n  return(vec)\n}\n\n#' calculate the RMSE or NRMSE\n#' \n#' This function calculate imputation error given the imputed data, the missing\n#' data and the true data\n#' \n#' @param imp the imputaed data matrix\n#' @param mis the missing data matrix\n#' @param true the true data matrix\n#' @param norm logical, if TRUE then the normalized RMSE will be returned\n#' \n#' @export\nRmse <- function(imp, mis, true, norm = FALSE) {\n  # if norm is true, calculate the normalised RMSE\n  # coerce both matrices into vectors\n  \n  imp <- as.matrix(imp)\n  mis <- as.matrix(mis)\n  true <- as.matrix(true)\n  \n  missIndex <- which(is.na(mis))\n  errvec <- imp[missIndex] - true[missIndex]\n  rmse <- sqrt(mean(errvec^2))\n  if (norm) {\n    rmse <- rmse/sd(true[missIndex])\n  }\n  return(rmse)\n}\n\n\n#' calculate miss-classification error \n#' \n#' This function calculates the misclassfication error given the imputed data, \n#' the missing data and the true data.\n#' @param imp the imputaed data matrix\n#' @param mis the missing data matrix\n#' @param true the ture data matrix\n#' @export \nmr <- function(imp, mis, true) {\n  \n  # if norm is true, calculate the normalised RMSE\n  # coerce both matrices into vectors\n  \n  imp <- as.matrix(imp)\n  mis <- as.matrix(mis)\n  true <- as.matrix(true)\n  \n  missIndex <- which(is.na(mis))\n  errvec <- table(as.numeric(imp[missIndex]), as.matrix(true)[missIndex])\n  mr <- 1 - (sum(diag(errvec))/sum(errvec))\n  return(mr)\n}\n  \n#' Plot function for imputation\n#' \n#' this is a plot function for assessing imputation performance given the imputed data\n#' and the original true data\n#' @param imp the imputed data matrix\n#' @param mis the missing data matrix\n#' @param true, the true data matrix\n#' @param ... other arguments that can be passed to plot\n#' @export\nplotIm <- function(imp, mis, true, ...) {\n  imp <- as.matrix(imp)\n  mis <- as.matrix(mis)\n  true <- as.matrix(true)\n  \n  missIndex <- which(is.na(mis))\n  plot(imp[missIndex], true[missIndex], xlab = \"Imputed Value\", pch = 19, \n       cex = 0.8, ylab = \"True Value\", main = \"Imputation Performance\", ...)\n  abline(0, 1, col = 2, lwd = 1.2, lty = 2)\n  \n}\n\n#' Impute missing data matrix by some other imputation methods\n#' \n#' This function uses some other imputation methods that are not introduced in\n#' our package. \n#' @param method is the imputation method, possibly from other packages\n#' @param misdata is the missing data need to be imputed\n#' @param truedata is the true data matrix\n#' @param ... some other arguments that can be passed to method\n#' \n#' @export\notherIm <- function(method = NULL, misdata = simdata, truedata = data, ...) {\n  \n  FUN <- match.fun(method)\n  if (identical(FUN, SVDmiss)) {\n    impdata<- FUN(misdata, ...)$Xfill\n  }\n  else {\n    impdata<- FUN(misdata, ...)$x\n  }\n  rmse <- Rmse(impdata, misdata, truedata, norm = TRUE)\n  plotIm(impdata, misdata, data)\n  return(rmse)\n}\n\n# \n# ma = function(i) {\n#   i[is.na(i)] <- mean(i, na.rm = TRUE)\n#   return(i)\n# }\n\n\n#' Evaluate the performance of a imputation method by simulation\n#' \n#' @param data is the complete data matrix that will be used for simulation\n#' @param task task type, either be 1 for regression, 2 for classification or 3 for\n#' mixed type\n#' @param p is the percentage of missing values that will be introduction into\n#'   data, it has to be a value between 0 and 1\n#' @param n.sim the number of simulations, default is 100 times\n#' @param ini is the initialization setting for some relevant imputation methods\n#'   , the default setting is \"mean\", while \"median\" and \"random\" can also be \n#'   used. See also \\code{\\link{guess}}\n#' @param method the imputaion method based on variable selection for simulation\n#'   some other imputation method can be passed to the 'other' argument\n#' @param guess logical value, if is TRUE, then \\code{\\link{guess}} will be used\n#'   as the imputation method for simulation\n#' @param guess.type, guess type for the guess function. It cannot be NULL if guess is TRUE\n#' @param other some other imputation method that is based on variable selection\n#'   can be used. The requirement for this 'other' method is strict: it receives\n#'   a data matrix including missing values and returns a complete data matrix.\n#' @param verbose logical, if TRUE, additional output information will be provided \n#'   during iterations, i.e., the method that is using, the iteration number,\n#'   the convegence difference as compared to the precious iteration. The \n#'   progression bar will show up irrespective of this option and it can not be\n#'   got rid of. \n#'   @param seed set the seed for simulation so simulations using different imputation\n#'   methods are comparable. The default value is set to 1234, which is not supposed to \n#'   mean anything. But if 1234 is used, then the seed for simulating the first\n#'   missing data matrix is 1234, then it sums by one for every subsequent\n#'   simulationg data matrix. \n#' @export\nSimEval <- function(data, task = NULL, p = 0.1, n.sim = 100, ini = \"mean\", \n                    method = NULL, guess = FALSE, guess.type = NULL, \n                    other = NULL, verbose = TRUE, seed = 1234) {\n  if (!guess & is.null(method) & is.null(other)) {\n    stop(\"Please provide a method to impute or you can guess by setting 'guess = TRUE'\")\n    }\n  if (!is.null(other)) {\n    otherFun <- match.fun(other)\n  }\n  Type <- Detect(data)\n  if (is.null(task)) {\n    if(all(Type == \"numeric\")) {\n      task <- 1\n      Fun1 <- method\n      names(task) <- \"Regression\"\n    } else if(all(Type == \"character\")) {\n      task <- 2\n      Fun2 <- method\n      names(task) <- 'Classification'\n    } else {\n      task <- 3\n      if (length(method) != 2) stop (\"data is mix type, please provide two functions\")\n      Fun1 <- method[1]\n      Fun2 <- method[2]\n      names(task) <- \"Regression and Classification mixed\"\n    }\n  } else {\n    if (task == 1) {\n      Fun1 <- method\n    } else if (task == 2) {\n      Fun2 <- method\n    } else {\n      Fun1 <- method[1]\n      Fun2 <- method[2]\n    }\n  }\n  time <- numeric(n.sim)\n  error <- numeric(n.sim)\n  if (!guess & is.null(other)) {\n    conv <- vector(\"list\", n.sim)\n  }\n  pb <- txtProgressBar(min = 0, max = n.sim, style = 3)\n  for (i in seq_len(n.sim)) {\n    setTxtProgressBar(pb, i)\n    set.seed(seed + i)\n    simdata <- SimIm(data, p = p)\n    if (!guess & is.null(other)) {\n      if (task == 1) {\n        time[i] <- system.time(imp <- impute(simdata, ini = ini, lmFun = Fun1, \n                                           verbose = verbose))[3] \n        error[i] <- Rmse(imp$imp, simdata, data, norm = TRUE)\n        conv[[i]] <- length(imp$conv)\n        } else if (task == 2) {\n        time[i] <- system.time(imp <- impute(simdata, cFun = Fun2, \n                                             verbose = verbose))[3] \n        error[i] <- mr(imp$imp, simdata, data)\n        conv[[i]] <- length(imp$conv)\n      }\n      } else if (!is.null(other)) {\n        time[i] <- system.time(imp <- otherFun(simdata))[3]\n        error[i] <- Rmse(imp, simdata, data, norm = TRUE)\n      } else {\n        stopifnot(!is.null(guess.type))\n        time[i] <- system.time(imp <- guess(simdata, type = guess.type))[3]\n        error[i] <- Rmse(imp, simdata, data, norm = TRUE)\n      }\n    close(pb)\n  }\nif (guess | !is.null(other)) {\n  conv <- \"No convergence\"\n}\n  return(list(call = as.character(substitute(method)), task = task, time = mean(time),\n              error = error, conv = conv))\n}\n\n#' Detect variable type in a data matrix\n#' \n#' This function detects the type of the variables in a data matrix. Types \n#' can be continuous only, categorical only or mixed type. The rule for\n#' defining a variable as a categorical variable is when: (1) it is a character\n#' vector, (2) it contains no more than n = 5 unique values\n#' @param x is the data matrix that need to be detected. \n#' @param n is a number, indicating how many levels, if outnumbered, can be seen\n#' as an numeric variable, rather than a categorical variable. \n#' @export\nDetect <- function(x, n = 5) {\n  if (!is.matrix(x) & !is.data.frame(x)) {\n    stop(\"x has to be either a matrix or data frame\")\n  }\n  \n  f.new <- function(z) {\n    \n    if (is.factor(z)) {\n      return (\"character\")\n    } else if (is.numeric(z) && length(unique(unclass(x))) > n) {\n      # using class here to avoid the warnings if applied to a factor\n      return (\"numeric\")\n    } else {\n      return (\"character\")\n    }\n  }\n  p <- sapply(x, f.new)\n  return (varType = p)\n}\n\n\n#' Impute by guessing\n#' \n#' This function use some primitive methods, including mean imputation, \n#' median imputation, random guess, or majority imputation (only for categorical\n#' variables), to impute a missing data matrix.\n#' @param x a matrix or data frame\n#' @param type is the guessing type, including \"mean\" for mean imputation, \n#' \"median\" for median imputation, \"random\" for random guess, and \"majority\" for\n#' majority imputation for categorical variables. \n#' @export\nguess <- function(x, type = \"mean\") {\n  # this function impute a missing data matrix by some guess\n  # type can be \"mean\", \"median\", \"random\", or \"majority\" (only for discrete)\n  major <- function(x) {\n    max.level <- max(table(as.factor(x)))\n    ## if there are several classes which are major, sample one at random\n    class.assign <- sample(names(which(max.level == summary(as.factor(x)))), 1)\n    x[is.na(x)] <- class.assign\n    return(x)\n  }\n  \n  switch(type,\n         mean = sapply(as.data.frame(x), FUN = function(i) {\n           i[is.na(i)] <- mean(i, na.rm = TRUE)\n           return(i)\n         }),\n         median = sapply(as.data.frame(x), FUN = function(i) {\n           i[is.na(i)] <- median(i, na.rm = TRUE)\n           return(i)\n         }),\n         random = sapply(as.data.frame(x), FUN = function(i) {\n           i[is.na(i)] <- sample(na.omit(i), 1)\n           return(i)\n         }),\n         majority = apply(sapply(as.data.frame(x), FUN = major), 2, as.numeric)\n         \n  )\n}",
    "created" : 1395561512018.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1557021009",
    "id" : "7EB8844E",
    "lastKnownWriteTime" : 1394861346,
    "path" : "~/Downloads/deleted/impute-master/R/funs.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}